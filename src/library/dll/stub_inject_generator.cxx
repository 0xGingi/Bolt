#include "stub_inject.hxx"
#include <iostream>

/// This program is run by the build system on Windows. It manually maps the stub DLL, then outputs some C++ code which
/// writes that DLL into a target process, invokes the payload on a remote thread, and blocks until that thread returns.
/// The "stub DLL" is part of the RS3 plugin loader for Windows. It refers to a DLL which is injected into the game launch
/// process so that it can follow CreateProcess calls and inject the actual plugin loader into the actual game client.
/// The function generated by this code will be called from window_launcher_win.cxx when launching the game.
int wmain(int argc, const wchar_t **argv) {
    if (argc != 3) {
        std::cerr << "stub_generator must be called with exactly two arguments: the absolute path to the stub DLL and the absolute path to stub_inject.hxx." << std::endl;
        return 1;
    }
    HANDLE stub_file = CreateFileW(argv[1], GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
    if (stub_file == INVALID_HANDLE_VALUE) {
        std::cerr << "stub_generator could not open the dll file: ";
        std::wcerr << argv[1];
        std::cerr << std::endl;
        return 1;
    }
    DWORD stub_file_size = GetFileSize(stub_file, NULL);
    PVOID stub_dll = VirtualAlloc(NULL, stub_file_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!ReadFile(stub_file, stub_dll, stub_file_size, nullptr, nullptr)) {
        std::cerr << "stub_generator could not read the dll file: " << GetLastError() << std::endl;
        return 1;
    }

    PIMAGE_DOS_HEADER stub_dos_header = (PIMAGE_DOS_HEADER)stub_dll;
    PIMAGE_NT_HEADERS stub_nt_headers = (PIMAGE_NT_HEADERS)((LPBYTE)stub_dll + stub_dos_header->e_lfanew);
    PIMAGE_SECTION_HEADER stub_section_header = (PIMAGE_SECTION_HEADER)(stub_nt_headers + 1);

    // find a function in the export table with ordinal value 1, so we can hard-code its RVA.
    // this assumes the whole export table of stub.dll is in one section.
    DWORD entry_point_rva = 0;
    IMAGE_DATA_DIRECTORY stub_export_virtual_details = stub_nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
    for (size_t i = 0; i < stub_nt_headers->FileHeader.NumberOfSections; i += 1) {
        if (stub_section_header[i].VirtualAddress > stub_export_virtual_details.VirtualAddress) continue;
        if (stub_section_header[i].VirtualAddress + stub_section_header[i].Misc.VirtualSize <= stub_export_virtual_details.VirtualAddress) continue;
        const DWORD export_section_offset = stub_section_header[i].PointerToRawData - stub_section_header[i].VirtualAddress;
        PIMAGE_EXPORT_DIRECTORY stub_exports = (PIMAGE_EXPORT_DIRECTORY)((LPBYTE)stub_dll + (stub_export_virtual_details.VirtualAddress + export_section_offset));
        PDWORD export_address_list = (PDWORD)((LPBYTE)stub_dll + (stub_exports->AddressOfFunctions + export_section_offset));
        entry_point_rva = export_address_list[BOLT_STUB_ENTRYORDINAL - stub_exports->Base];
        break;
    }
    if (!entry_point_rva) {
        std::cerr << "stub_generator could not locate entry point" << std::endl;
        return 1;
    }

    // output file header and #include lines
    std::cout << "// This file was created programmatically by Bolt's build system. Don't change this file - change the code that generated it." << std::endl;
    std::cout << "#include <Windows.h>" << std::endl << "#include <cstdint>" << std::endl << "#include \"";
    std::wcout << argv[2];
    std::cout << "\"" << std::endl;
    // embed dll headers
    std::cout << "static constexpr uint8_t dll_headers[] = {";
    for (size_t i = 0; i < stub_nt_headers->OptionalHeader.SizeOfHeaders; i += 1) {
        if (i != 0) std::cout << ",";
        std::cout << (WORD)((LPBYTE)stub_dll)[i];
    }
    std::cout << "};" << std::endl;
    // embed dll sections
    for (size_t i = 0; i < stub_nt_headers->FileHeader.NumberOfSections; i += 1) {
        std::cout << "static constexpr uint8_t section" << i << "[] = {";
        LPBYTE section_start = (LPBYTE)stub_dll + stub_section_header[i].PointerToRawData;
        for (size_t j = 0; j < stub_section_header[i].SizeOfRawData; j += 1) {
            if (j != 0) std::cout << ",";
            std::cout << (WORD)section_start[j];
        }
        std::cout << "};" << std::endl;
    }
    // embed the amount of zeroes we'll need (WriteProcessMemory needs actual memory to copy from)
    std::cout << "static const uint8_t zeroes[" << stub_nt_headers->OptionalHeader.SizeOfHeaders << "];" << std::endl;

    std::cout << "void InjectStub(HANDLE process) {" << std::endl;
    // allocate memory in the remote process
    std::cout << "LPBYTE dll = (LPBYTE)VirtualAllocEx(process, nullptr, " << stub_nt_headers->OptionalHeader.SizeOfImage << ", MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);" << std::endl;
    // copy DLL headers to the target process
    std::cout << "WriteProcessMemory(process, dll, (PVOID)dll_headers, " << stub_nt_headers->OptionalHeader.SizeOfHeaders << ", nullptr);" << std::endl;
    // copy each section to the target process
    for (size_t i = 0; i < stub_nt_headers->FileHeader.NumberOfSections; i += 1) {
        std::cout << "WriteProcessMemory(process, (PVOID)(dll + " << stub_section_header[i].VirtualAddress << "), (PVOID)section" << i << ", " << stub_section_header[i].SizeOfRawData << ", nullptr);" << std::endl;
    }
    // fix relocations
    std::cout <<
        "const ptrdiff_t reloc_delta = (ptrdiff_t)(dll - " << stub_nt_headers->OptionalHeader.ImageBase << ");"
        "PIMAGE_BASE_RELOCATION remote_reloc_address = (PIMAGE_BASE_RELOCATION)(dll + " << stub_nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress << ");"
        "WORD offset;"
        "DWORD ptr;"
        "while (true) {"
          "IMAGE_BASE_RELOCATION remote_reloc;"
          "ReadProcessMemory(process, (LPCVOID)remote_reloc_address, (LPVOID)&remote_reloc, sizeof(remote_reloc), nullptr);"
          "if (!remote_reloc.VirtualAddress) break;"
          "if (remote_reloc.SizeOfBlock > sizeof(remote_reloc)) {"
            "PWORD list = (PWORD)(remote_reloc_address + 1);"
            "for (size_t i = 0; i < (remote_reloc.SizeOfBlock - sizeof(remote_reloc)) / sizeof(WORD); i += 1) {"
              "ReadProcessMemory(process, (LPCVOID)(list + i), (LPVOID)&offset, sizeof(offset), nullptr);"
              "if (!offset) continue;"
              "LPVOID remote_ptr_address = (LPVOID)(dll + remote_reloc.VirtualAddress + (offset & 0xFFF));"
              "ReadProcessMemory(process, (LPCVOID)remote_ptr_address, (LPVOID)&ptr, sizeof(ptr), nullptr);"
              "ptr += reloc_delta;"
              "WriteProcessMemory(process, remote_ptr_address, (LPCVOID)&ptr, sizeof(ptr), nullptr);"
            "}"
          "}"
          "remote_reloc_address = (PIMAGE_BASE_RELOCATION)((LPBYTE)remote_reloc_address + remote_reloc.SizeOfBlock);"
        "}";
    std::cout << std::endl;
    // set rwx permissions for each section
    std::cout << "DWORD oldp;" << std::endl;
    for (size_t i = 0; i < stub_nt_headers->FileHeader.NumberOfSections; i += 1) {
        const bool readp =(stub_section_header[i].Characteristics & IMAGE_SCN_MEM_READ);
        const bool writep =(stub_section_header[i].Characteristics & IMAGE_SCN_MEM_WRITE);
        const bool execp =(stub_section_header[i].Characteristics & IMAGE_SCN_MEM_EXECUTE);
        const DWORD permission =
            readp ?
                writep ?
                    execp ? PAGE_EXECUTE_READWRITE : PAGE_READWRITE
                :
                    execp ? PAGE_EXECUTE_READ : PAGE_READONLY
            :
                writep ?
                    execp ? PAGE_EXECUTE_WRITECOPY : PAGE_WRITECOPY
                :
                    execp ? PAGE_EXECUTE : PAGE_NOACCESS;
        std::cout << "VirtualProtectEx(process, (LPVOID)(dll + " << stub_section_header[i].VirtualAddress << "), " << stub_section_header[i].Misc.VirtualSize << ", " << permission << ", &oldp);" << std::endl;
    }
    // invoke entrypoint
    std::cout << "StubInjectParams params = {.kernel32=GetModuleHandleW(L\"kernel32.dll\"), .pGetModuleHandleW=GetModuleHandleW, .pGetProcAddress=GetProcAddress};" << std::endl;
    std::cout << "StubInjectParams* remote_params = (StubInjectParams*)VirtualAllocEx(process, nullptr, sizeof(StubInjectParams), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);" << std::endl;
    std::cout << "WriteProcessMemory(process, remote_params, &params, sizeof(params), nullptr);" << std::endl;
    std::cout << "HANDLE remote_thread = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)(dll + " << entry_point_rva << "), remote_params, 0, NULL);" << std::endl;
    std::cout << "WaitForSingleObject(remote_thread, INFINITE);" << std::endl;
    std::cout << "VirtualFreeEx(process, remote_params, 0, MEM_RELEASE);" << std::endl;

    // wipe dll headers from remote process
    std::cout << "WriteProcessMemory(process, dll, (PVOID)zeroes, " << stub_nt_headers->OptionalHeader.SizeOfHeaders << ", nullptr);" << std::endl;

    std::cout << "}" << std::endl;

    CloseHandle(stub_file);
    VirtualFree(stub_dll, stub_file_size, MEM_RELEASE);
    return 0;
}
