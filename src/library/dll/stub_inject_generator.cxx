#include "stub_inject.hxx"
#include <iostream>

/// This program is run by the build system on Windows. It manually maps the stub DLL, then outputs some C++ code which
/// writes that DLL into a target process, invokes the payload on a remote thread, and blocks until that thread returns.
/// The "stub DLL" is part of the RS3 plugin loader for Windows. It refers to a DLL which is injected into the game launch
/// process so that it can follow CreateProcess calls and inject the actual plugin loader into the actual game client.
/// The function generated by this code will be called from window_launcher_win.cxx when launching the game.
int wmain(int argc, const wchar_t **argv)
{
    if (argc != 3)
    {
        std::cerr << "stub_generator must be called with exactly two arguments: the absolute path to the stub DLL and the absolute path to stub_inject.hxx." << std::endl;
        return 1;
    }
    HANDLE stub_file = CreateFileW(argv[1], GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
    if (stub_file == INVALID_HANDLE_VALUE)
    {
        std::cerr << "stub_generator could not open the dll file: ";
        std::wcerr << argv[1];
        std::cerr << std::endl;
        return 1;
    }
    DWORD stub_file_size = GetFileSize(stub_file, NULL);
    PVOID stub_dll = VirtualAlloc(NULL, stub_file_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!ReadFile(stub_file, stub_dll, stub_file_size, nullptr, nullptr))
    {
        std::cerr << "stub_generator could not read the dll file: " << GetLastError() << std::endl;
        return 1;
    }

    PIMAGE_DOS_HEADER stub_dos_header = (PIMAGE_DOS_HEADER)stub_dll;
    PIMAGE_NT_HEADERS stub_nt_headers = (PIMAGE_NT_HEADERS)((LPBYTE)stub_dll + stub_dos_header->e_lfanew);
    PIMAGE_SECTION_HEADER stub_section_header = (PIMAGE_SECTION_HEADER)(stub_nt_headers + 1);
    std::cout << "// This file was created programmatically by Bolt's build system. Don't change this file - change the code that generated it." << std::endl;
    std::cout << "#include <Windows.h>" << std::endl << "#include <cstdint>" << std::endl << "#include \"";
    std::wcout << argv[2];
    std::cout << "\"" << std::endl;
    // embed dll headers
    std::cout << "static constexpr uint8_t dll_headers[] = {";
    for (size_t i = 0; i < stub_nt_headers->OptionalHeader.SizeOfHeaders; i += 1)
    {
        if (i != 0)
            std::cout << ",";
        std::cout << (WORD)((LPBYTE)stub_dll)[i];
    }
    std::cout << "};" << std::endl;
    // embed dll sections
    for (size_t i = 0; i < stub_nt_headers->FileHeader.NumberOfSections; i += 1)
    {
        std::cout << "static constexpr uint8_t section" << i << "[] = {";
        LPBYTE section_start = (LPBYTE)stub_dll + stub_section_header[i].PointerToRawData;
        for (size_t j = 0; j < stub_section_header[i].SizeOfRawData; j += 1)
        {
            if (j != 0)
                std::cout << ",";
            std::cout << (WORD)section_start[j];
        }
        std::cout << "};" << std::endl;
    }

    std::cout << "void InjectStub(HANDLE process) {" << std::endl;
    // allocate memory in the remote process
    std::cout << "PVOID dll = VirtualAllocEx(process, nullptr, " << stub_nt_headers->OptionalHeader.SizeOfImage << ", MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);" << std::endl;
    // copy DLL headers to the target process
    std::cout << "WriteProcessMemory(process, dll, (PVOID)dll_headers, " << stub_nt_headers->OptionalHeader.SizeOfHeaders << ", nullptr);" << std::endl;
    // copy each section to the target process
    for (size_t i = 0; i < stub_nt_headers->FileHeader.NumberOfSections; i += 1) {
        std::cout << "WriteProcessMemory(process, (PVOID)((LPBYTE)dll + " << stub_section_header[i].VirtualAddress << "), (PVOID)section" << i << ", " << stub_section_header[i].SizeOfRawData << ", nullptr);" << std::endl;
    }
    // fix relocations
    std::cout <<
        "const ptrdiff_t reloc_delta = (ptrdiff_t)((LPBYTE)dll - " << stub_nt_headers->OptionalHeader.ImageBase << ");"
        "PIMAGE_BASE_RELOCATION remote_reloc_address = (PIMAGE_BASE_RELOCATION)((LPBYTE)dll + " << stub_nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress << ");"
        "WORD offset;"
        "DWORD ptr;"
        "while (true) {"
          "IMAGE_BASE_RELOCATION remote_reloc;"
          "ReadProcessMemory(process, (LPCVOID)remote_reloc_address, (LPVOID)&remote_reloc, sizeof(remote_reloc), nullptr);"
          "if (!remote_reloc.VirtualAddress) break;"
          "if (remote_reloc.SizeOfBlock > sizeof(remote_reloc)) {"
            "PWORD list = (PWORD)(remote_reloc_address + 1);"
            "for (size_t i = 0; i < (remote_reloc.SizeOfBlock - sizeof(remote_reloc)) / sizeof(WORD); i += 1) {"
              "ReadProcessMemory(process, (LPCVOID)(list + i), (LPVOID)&offset, sizeof(offset), nullptr);"
              "if (!offset) continue;"
              "LPVOID remote_ptr_address = (LPVOID)((LPBYTE)dll + remote_reloc.VirtualAddress + (offset & 0xFFF));"
              "ReadProcessMemory(process, (LPCVOID)remote_ptr_address, (LPVOID)&ptr, sizeof(ptr), nullptr);"
              "ptr += reloc_delta;"
              "WriteProcessMemory(process, remote_ptr_address, (LPCVOID)&ptr, sizeof(ptr), nullptr);"
            "}"
          "}"
          "remote_reloc_address = (PIMAGE_BASE_RELOCATION)((LPBYTE)remote_reloc_address + remote_reloc.SizeOfBlock);"
        "}";
    std::cout << std::endl;
    // set rwx permissions for each section
    std::cout << "DWORD oldp;" << std::endl;
    for (size_t i = 0; i < stub_nt_headers->FileHeader.NumberOfSections; i += 1) {
        const bool readp =(stub_section_header[i].Characteristics & IMAGE_SCN_MEM_READ);
        const bool writep =(stub_section_header[i].Characteristics & IMAGE_SCN_MEM_WRITE);
        const bool execp =(stub_section_header[i].Characteristics & IMAGE_SCN_MEM_EXECUTE);
        const DWORD permission =
            readp ?
                writep ?
                    execp ? PAGE_EXECUTE_READWRITE : PAGE_READWRITE
                :
                    execp ? PAGE_EXECUTE_READ : PAGE_READONLY
            :
                writep ?
                    execp ? PAGE_EXECUTE_WRITECOPY : PAGE_WRITECOPY
                :
                    execp ? PAGE_EXECUTE : PAGE_NOACCESS;
        std::cout << "VirtualProtectEx(process, (LPVOID)((LPBYTE)dll + " << stub_section_header[i].VirtualAddress << "), " << stub_section_header[i].Misc.VirtualSize << ", " << permission << ", &oldp);" << std::endl;
    }
    
    std::cout << "}" << std::endl;

    CloseHandle(stub_file);
    VirtualFree(stub_dll, stub_file_size, MEM_RELEASE);
    return 0;
}
