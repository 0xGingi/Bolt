<!--Main page displayed by the launcher. Basically just a javascript file with a couple of HTML tags around it.-->
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>Bolt Launcher</title>
		<script>
			var root = null;
			var messages = document.createElement("ul");
			var credentials = null;
			var pendingGameAuth = null;
			var rs3_linux_installed_hash = null;

			// checks if `credentials` are about to expire or have already expired,
			// and renews them using the oauth endpoint if so
			function checkRenewCreds(url, client_id) {
				return new Promise((resolve, reject) => {
					// only renew if less than 30 seconds left
					if (credentials.expiry - Date.now() < 30000) {
						const post_data = new URLSearchParams({
							grant_type: "refresh_token",
							client_id: client_id,
							refresh_token: credentials.refresh_token
						});
						var xml = new XMLHttpRequest();
						xml.onreadystatechange = () => {
							if (xml.readyState == 4 && xml.status == 200) {
								parseCredentials(xml.response);
								resolve(null);
							} else if (xml.status >= 400) {
								reject(xml.status);
							}
						};
						xml.open('POST', url, true);
						xml.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
						xml.setRequestHeader("Accept", "application/json");
						xml.send(post_data);
					} else {
						resolve(null);
					}
				});
			}

			// parses a response from the oauth endpoint into the `credentials` var
			function parseCredentials(str) {
				const oauth_creds = JSON.parse(str);
				const sections = oauth_creds.id_token.split('.');
				if (sections.length !== 3) {
					err(`Malformed id_token: ${sections.length} sections, expected 3`);
				}
				const header = JSON.parse(atob(sections[0]));
				if (header.typ !== "JWT") {
					err(`Bad id_token header: typ ${header.typ}, expected JWT`);
				}
				const payload = JSON.parse(atob(sections[1]));
				credentials = {
					access_token: oauth_creds.access_token,
					id_token: oauth_creds.id_token,
					refresh_token: oauth_creds.refresh_token,
					sub: payload.sub,
					login_provider: payload.login_provider || null,
					expiry: Date.now() + (oauth_creds.expires_in * 1000)
				};
			}

			// builds the url to be opened in the login window
			// async because crypto.subtle.digest is async for some reason, so remember to `await`
			async function makeLoginUrl(e) {
				const verifier_data = new TextEncoder().encode(e.pkceCodeVerifier);
				const digested = await crypto.subtle.digest("SHA-256", verifier_data);
				var raw = "";
				var bytes = new Uint8Array(digested);
				for (var i = 0; i < bytes.byteLength; i++) {
					raw += String.fromCharCode(bytes[i]);
				}
				const code_challenge = btoa(raw).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
				return e.origin.concat("/oauth2/auth?").concat(new URLSearchParams({
					auth_method: e.authMethod,
					login_type: e.loginType,
					flow: e.flow,
					response_type: "code",
					client_id: e.clientid,
					redirect_uri: e.redirect,
					code_challenge: code_challenge,
					code_challenge_method: "S256",
					prompt: "login",
					scope: "openid offline gamesso.token.create user.profile.read",
					state: e.pkceState
				}));
			}

			// builds a random PKCE verifier string using crypto.getRandomValues
			function make_random_verifier() {
				var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
				var n = new Uint32Array(43);
				crypto.getRandomValues(n);
				return Array.from(n, function(e) {
					return t[e % t.length]
				}).join("")
			}

			// builds a random PKCE state string using crypto.getRandomValues
			function make_random_state() {
				var t = 0;
				var r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
				var n = r.length - 1;
	
				var o = crypto.getRandomValues(new Uint8Array(12));
				return Array.from(o).map((e) => {
					return Math.round(e * (n - t) / 255 + t)
				}).map((e) => { return r[e]; }).join("")
			}

			// body's onload function
			function start(s) {
				root = document.body;
				root.appendChild(footer(false));
				const state = make_random_state();
				const verifier = make_random_verifier();
				const client_id = atob(s.clientid);
				const exchange_url = atob(s.origin).concat("/oauth2/token");

				const query = new URLSearchParams(window.location.search);
				rs3_linux_installed_hash = query.get("rs3_linux_installed_hash");
				credentials = query.get("credentials");

				var w = window.open("about:blank", "", "width=480,height=720");
				window.addEventListener("message", (event) => {
					if (event.origin != "https://bolt-internal" && btoa(event.origin).replaceAll('\x3d', '') != s.origin) {
						console.log(`discarding message from origin ${event.origin}`);
						return;
					}
					switch (event.data.type) {
						case "authCode":
							if (event.data.state == state) {
								const post_data = new URLSearchParams({
									grant_type: "authorization_code",
									client_id: client_id,
									code: event.data.code,
									code_verifier: verifier,
									redirect_uri: atob(s.redirect)
								});
								var xml = new XMLHttpRequest();

								xml.onreadystatechange = () => {
									if (xml.readyState == 4 && xml.status == 200) {
										parseCredentials(xml.response);
										handleLogin(s, w, exchange_url, client_id, state);
									} else if (xml.status >= 400) {
										w.close();
										err(`Error: from ${exchange_url}: ${xml.status}: ${xml.response}`);
									}
								};
								xml.open('POST', exchange_url, true);
								xml.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
								xml.setRequestHeader("Accept", "application/json");
								xml.send(post_data);

							}
							break;
						case "initAuth":
							console.log(`message: init auth: ${event.data.auth_method}`);
							break;
						case "externalUrl":
							console.log(`message: external url: ${event.data.url}`);
							break;
						case "gameSessionServerAuth":
							if (pendingGameAuth && pendingGameAuth.state == event.data.state) {
								w.close();
								const sections = event.data.id_token.split('.');
								if (sections.length !== 3) {
									err(`Malformed id_token: ${sections.length} sections, expected 3`);
								}
								const header = JSON.parse(atob(sections[0]));
								if (header.typ !== "JWT") {
									err(`Bad id_token header: typ ${header.typ}, expected JWT`);
								}
								const payload = JSON.parse(atob(sections[1]));
								if (atob(payload.nonce) !== pendingGameAuth.nonce) {
									err("Incorrect nonce in id_token");
								}
								const sessions_url = atob(s.auth_api).concat("/sessions");
								var xml = new XMLHttpRequest();
								xml.onreadystatechange = () => {
									if (xml.readyState == 4 && xml.status == 200) {
										const accounts_url = atob(s.auth_api).concat("/accounts");
										const session_id = JSON.parse(xml.response).sessionId;
										var xml2 = new XMLHttpRequest();
										xml2.onreadystatechange = () => {
											if (xml2.readyState == 4 && xml2.status == 200) {
												pendingGameAuth.account_info_promise.then((account_info) => {
													pendingGameAuth = null;
													clearRoot();
													var select = document.createElement("select");
													JSON.parse(xml2.response).forEach((acc) => {
														var opt = document.createElement("option");
														opt.value = acc.accountId;
														if (acc.displayName) {
															opt.name = acc.displayName;
															opt.innerText = acc.displayName;
														} else {
															opt.innerText = `#${acc.accountId}`;
														}
														select.appendChild(opt);
													});
													var logged_in = document.createElement("p");
													logged_in.innerHTML = `Currently logged in as <b>${account_info.displayName}</b>#${account_info.suffix}`;
													root.appendChild(logged_in);
													var accounts = document.createElement("p");
													var accounts_label = document.createElement("label");
													accounts_label.for = select;
													accounts_label.innerText = "Account: ";
													accounts.appendChild(accounts_label);
													accounts.appendChild(select);
													root.appendChild(accounts);
													var rs3_linux = document.createElement("button");
													rs3_linux.onclick = () => {
														const acc_id = select.value;
														const acc_name = select.options[select.selectedIndex].getAttribute("name");
														launchRS3Linux(null, null, session_id, acc_id, acc_name);
													};
													rs3_linux.innerText = "Launch RS3";
													root.appendChild(rs3_linux);
													root.appendChild(footer(true));
												});
											} else if (xml2.status >= 400) {
												err(`Error: from ${accounts_url}: ${xml2.status}: ${xml2.response}`);
											}
										};
										xml2.open('GET', accounts_url, true);
										xml2.setRequestHeader("Accept", "application/json");
										xml2.setRequestHeader("Authorization", "Bearer ".concat(session_id));
										xml2.send();
									} else if (xml.status >= 400) {
										err(`Error: from ${sessions_url}: ${xml.status}: ${xml.response}`);
									}
								};
								xml.open('POST', sessions_url, true);
								xml.setRequestHeader("Content-Type", "application/json");
								xml.setRequestHeader("Accept", "application/json");
								xml.send(`{"idToken": "${event.data.id_token}"}`);
							}
							break;
						default:
							console.log("unknown message type: ".concat(event.data.type));
							break;
					}
				});

				if (credentials) {
					handleLogin(s, w, exchange_url, client_id, state);
				} else {
					makeLoginUrl({
						origin: atob(s.origin),
						redirect: atob(s.redirect),
						authMethod: "",
						loginType: "",
						clientid: client_id,
						flow: "launcher",
						pkceState: state,
						pkceCodeVerifier: verifier,
					}).then((e) => { w.location.replace(e); });
				}
			}

			// called on new successful login with credentials, delegates to a specific handler based on login_provider value
			function handleLogin(s, w, exchange_url, client_id, state) {
				switch (credentials.login_provider) {
					case atob(s.provider):
						w.close();
						handleGameLogin(s, exchange_url, client_id);
						break;
					default:
						handleStandardLogin(s, w, exchange_url, client_id, state);
						break;
				}
			}

			// called when login was successful, but with absent or unrecognised login_provider
			function handleStandardLogin(s, w, refresh_url, client_id, state) {
				if (pendingGameAuth !== null) {
					throw new Error("game auth flow started while another was already pending");
				}
				const nonce = crypto.randomUUID();
				pendingGameAuth = {
					state: state,
					nonce: nonce,
					account_info_promise: new Promise((resolve, reject) => {
						const url = atob(s.api).concat("/users/").concat(credentials.sub).concat("/displayName");
						var xml = new XMLHttpRequest();
						xml.onreadystatechange = () => {
							if (xml.readyState == 4 && xml.status == 200) {
								resolve(JSON.parse(xml.response));
							} else if(xml.status >= 400) {
								reject(xml.status);
							}
						};
						xml.open('GET', url, true);
						xml.setRequestHeader("Authorization", "Bearer ".concat(credentials.access_token));
						xml.send();
					})
				};
				w.location.href = atob(s.origin).concat("/oauth2/auth?").concat(new URLSearchParams({
					id_token_hint: credentials.id_token,
					nonce: btoa(nonce),
					prompt: "consent",
					redirect_uri: "http://localhost",
					response_type: "id_token code",
					state: state,
					client_id: "1fddee4e-b100-4f4e-b2b0-097f9088f9d2",
					scope: "openid offline"
				}));
			}

			// called after successful login using a game account as the login_provider
			function handleGameLogin(s, refresh_url, client_id) {
				const auth_url = atob(s.profile_api).concat("/profile");
				var xml = new XMLHttpRequest();
				xml.onreadystatechange = () => {
					if (xml.readyState == 4 && xml.status == 200) {
						const name_info = JSON.parse(xml.response);
						clearRoot();
						var logged_in = document.createElement("p");
						if (name_info.displayNameSet) {
							logged_in.innerHTML = `Currently logged in as <b>${name_info.displayName}</b>`;
						} else {
							logged_in.innerText = "Currently logged in (no display name set)";
						}
						root.appendChild(logged_in);
						var rs3_linux = document.createElement("button");
						rs3_linux.onclick = () => {
							getShieldTokens(atob(s.shield_url), name_info.displayNameSet ? name_info.displayName : "", refresh_url, client_id)
								.then((e) => { launchRS3Linux(e.access_token, e.refresh_token, null, null, name_info.displayNameSet ? name_info.displayName : null);
							});
						};
						rs3_linux.innerText = "Launch RS3";
						root.appendChild(rs3_linux);
						root.appendChild(footer(true));
					}
				};
				xml.open('GET', auth_url, true);
				xml.setRequestHeader("Authorization", "Bearer ".concat(credentials.id_token));
				xml.send();
			}

			// use oauth creds to get a response from the "shield" endpoint
			function getShieldTokens(url, display_name, refresh_url, client_id) {
				return new Promise((resolve, reject) => {
					checkRenewCreds(refresh_url, client_id).then(() => {
						var xml = new XMLHttpRequest();
						xml.open('POST', url, true);
						xml.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
						xml.setRequestHeader("Authorization", "Basic Y29tX2phZ2V4X2F1dGhfZGVza3RvcF9yczpwdWJsaWM=");
						xml.onreadystatechange = () => {
							if (xml.readyState == 4 && xml.status == 200) {
								resolve(JSON.parse(xml.response));
							} else if (xml.status >= 400) {
								reject(xml.status);
							}
						};
						xml.send(new URLSearchParams({
							token: credentials.access_token,
							grant_type: "token_exchange",
							scope: "gamesso.token.create"
						}));
					});
				});
			}

			// launch RS3 via flatpak using the given env variables
			function launchRS3Linux(jx_access_token, jx_refresh_token, jx_session_id, jx_character_id, jx_display_name) {
				console.log(`launchRS3Linux(${jx_access_token}, ${jx_refresh_token}, ${jx_session_id}, ${jx_character_id}, ${jx_display_name})`);
			}

			// clears all content from root
			function clearRoot() {
				while (root.lastElementChild) {
					root.removeChild(root.lastElementChild);
				}
			}

			// generates footer element for pages
			function footer(separator) {
				if (separator) {
					root.appendChild(document.createElement("br"));
					var hr = document.createElement("hr");
					hr.style = "width: 85%;";
					root.appendChild(hr);
				}
				var d = document.createElement("div");
				var p = document.createElement("p");
				p.innerText = "Output:";
				d.appendChild(p);
				d.appendChild(messages);
				return d;
			}

			// adds an error message to the message list, then throws that error message
			function err(str) {
				var p = document.createElement("p");
				p.innerText = str;
				p.style = "background-color: #FF30303A;";
				var li = document.createElement("li");
				li.appendChild(p);
				messages.insertBefore(li, messages.firstChild);
				throw new Error(str);
			}
		</script>
	</head>
	<body style="overflow:hidden" onload="start(s())" />
</html>
